<?xml version="1.0" encoding="UTF-8"?>
<!--
		This template is for creating an Internet Draft using xml2rfc, which
		is available here: http://xml.resource.org.
	-->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced. 
     An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC2119 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC2629 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.2629.xml">
<!ENTITY RFC3552 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3552.xml">
<!ENTITY I-D.narten-iana-considerations-rfc2434bis SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.narten-iana-considerations-rfc2434bis.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc-ext refresh-from="draft-ietf-oauth-security-topics.xml"?> 
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="4"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!--
		control vertical white space (using these PIs as follows is
		recommended by the RFC Editor)
	-->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="bcp" 
	 docName="draft-ietf-oauth-security-topics-11"
     ipr="trust200902">
  <!--
		category values: std, bcp, info, exp, and historic ipr values:
		full3667, noModification3667, noDerivatives3667 you can add the
		attributes updates="NNNN" and obsoletes="NNNN" they will automatically
		be output with "(if approved)"
	-->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!--
			The abbreviated title is used in the page header - it is only
			necessary if the full title is longer than 39 characters
		-->

    <title abbrev="Security Topics">OAuth 2.0 Security Best Current Practice</title>

    <author fullname="Torsten Lodderstedt" initials="T." role="editor"
            surname="Lodderstedt">
      <organization>yes.com</organization>

      <address>
        <email>torsten@lodderstedt.net</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
	</author>
    <author fullname="John Bradley" initials="J." surname="Bradley">
	  <organization>Yubico</organization>
      <address>
        <email>ve7jtb@ve7jtb.com</email>
      </address>
    </author>

    <author fullname="Andrey Labunets" initials="A." surname="Labunets">
      <organization>Facebook</organization>
      <address>
        <email>isciurus@fb.com</email>
      </address>
    </author>
    
    <author fullname="Daniel Fett" initials="D." surname="Fett">
      <organization>yes.com</organization>
      <address>
        <email>mail@danielfett.de</email>
      </address>
    </author>

    <date day="19" month="November" year="2018" />

    <!-- Meta-data Declarations -->

    <area>Security Area</area>

    <workgroup>Open Authentication Protocol</workgroup>

    <!--
			WG name at the upperleft corner of the doc, IETF is fine for
			individual submissions. If this element is not present, the default
			is "Network Working Group", which is used by the RFC Editor as a nod
			to the history of the IETF.
		-->

    <keyword>security</keyword>

    <keyword>oauth2</keyword>
    
    <keyword>best current practice</keyword>

    <!--
			Keywords will be incorporated into HTML output files in a meta tag
			but they have no effect on text or nroff output. If you submit your
			draft to the RFC Editor, the keywords will be used for the search
			engine.
		-->

    <abstract>
      <t>This document describes best current security practice for OAuth 2.0.
      It updates and extends the OAuth 2.0 Security Threat Model to incorporate
      practical experiences gathered since OAuth 2.0 was published and covers
      new threats relevant due to the broader application of OAuth 2.0.</t>
    </abstract>
  </front>

  <middle>
    <section anchor="Introduction" title="Introduction">
      <t>It's been a while since OAuth has been published in 
	  <xref target="RFC6749">RFC 6749</xref> and <xref target="RFC6750">RFC 6750</xref>. 
	  Since publication, OAuth 2.0 has gotten massive traction in the market and became the 
	  standard for API protection and, as foundation of 
	  <xref target="OpenID">OpenID Connect</xref>, identity 
	  providing. While OAuth was used in a variety of scenarios and different kinds of 
	  deployments, the following challenges could be observed:
	  <list style="symbols">
	  <t>OAuth implementations are being attacked through known implementation 
	  weaknesses and anti-patterns (CSRF, referrer header). Although most of these
	  threats are discussed in the 
	  <xref target="RFC6819">OAuth 2.0 Threat Model and Security Considerations</xref>, 
	  continued exploitation 
 	  demonstrates there may be a need for more specific recommendations or that the existing 
	  mitigations are too difficult to deploy.</t>
	  <t>Technology has changed, e.g., the way browsers treat fragments in some situations, 
	  which may change the implicit grant's underlying security model.</t>
	  <t>OAuth is used in much more dynamic setups than originally anticipated, creating new 
	  challenges with respect to security. Those challenges go beyond the original 
	  scope of <xref target="RFC6749">RFC 6749</xref>, 
	  <xref target="RFC6749">RFC 6750</xref>, and 
	  <xref target="RFC6819">RFC 6819</xref>.</t>
	  </list>
	  </t>
	  <t>OAuth initially assumed a static relationship between client, authorization 
	  server and resource servers. The URLs of AS and RS were known to the client
	  at deployment time and built an anchor for the trust relationship among those
	  parties. The validation whether the client talks to a legitimate server was based on 
	  TLS server authentication (see <xref target="RFC6819"/>, Section 4.5.4).
	  With the increasing adoption of OAuth, this simple model dissolved and, in
	  several scenarios, was replaced by a dynamic establishment of the relationship
	  between clients on one side and the authorization and resource servers of a 
	  particular deployment on the other side. This way the same client could be 
	  used to access services of different providers (in case of standard APIs, such 
	  as e-Mail or OpenID Connect) or serves as a frontend to a particular tenant in a 
	  multi-tenancy.
	  Extensions of OAuth, such as <xref target="RFC7591"/> and 
	  <xref target="RFC8414"/> were developed in order to support
	  the usage of OAuth in dynamic scenarios.
	  As a challenge to the community, such usage scenarios open up new attack angles, 
	  which are discussed in this document.</t>	  
	  
	  <t>The remainder of the document is organized as follows: The next section 
	  summarizes the most important recommendations of the OAuth working group
	  for every OAuth implementor. Afterwards, a detailed analysis of the threats and 
	  implementation issues which can be found in the wild today is given 
	  along with a discussion of potential countermeasures.</t>
    </section>
    
    <section anchor="recommendations" title="Recommendations">
    <t>This section describes the set of security mechanisms the OAuth working group 
    recommendeds to OAuth implementers.</t>

    <section anchor="rec_redirect" title="Protecting Redirect-Based Flows">

    <t>Authorization servers MUST utilize exact matching of client redirect URIs against 
    pre-registered URIs. This measure contributes to the prevention of leakage of 
    authorization codes and access tokens (depending on the grant type). It also helps
    to detect mix-up attacks.</t>
	<t>Clients SHOULD avoid forwarding the user’s browser to a URI obtained from a 
	query parameter since such a function could be utilized to exfiltrate authorization 
	codes and access tokens. If there is a strong need for this kind of redirects, clients 
	are advised to implement appropriate countermeasures against open redirection, 
	e.g., as described by the <xref target="owasp">OWASP</xref>.</t>
	
	<t>Clients MUST prevent CSRF and ensure that each authorization response is only
        accepted once. One-time use CSRF tokens carried in the 
        <spanx style="verb">state</spanx> parameter, which are securely bound to the 
        user agent, SHOULD be used for that purpose.</t>
        
	<t>In order to prevent mix-up attacks, clients MUST only process redirect responses 
	of the OAuth authorization server they send the respective request to and from the 
	same user agent this authorization request was initiated with. Clients MUST memorize 
	which authorization server they sent an authorization request to and bind this 
	information to the user agent and ensure any sub-sequent messages are sent to the 
	same authorization server. Clients SHOULD use AS-specific redirect URIs as a means 
	to identify the AS a particular response came from.</t>
 
	<t>Note: <xref target="I-D.bradley-oauth-jwt-encoded-state"></xref> gives advice 
	on how to implement CSRF prevention and AS matching using signed JWTs in the 
	<spanx style="verb">state</spanx> parameter.</t>
	<section anchor="ac" title="Authorization Code Grant">
	<t>Clients utilizing the authorization grant type MUST use 
	<xref target="RFC7636">PKCE</xref> in order to (with the help 
	of the authorization server) detect and prevent attempts to inject (replay) 
	authorization codes 
	into the authorization response. The PKCE challenges must be transaction-specific and 
	securely bound to the user agent in which the transaction was started. OpenID
	Connect clients MAY use the <spanx style="verb">nonce</spanx> parameter of the 
	OpenID Connect authentication request as specified in <xref target="OpenID"/>
	in conjunction with the corresponding ID Token 
	claim for the same purpose.</t>
	<t>Note: although PKCE so far was recommended as 
	a mechanism to protect native apps, this advice applies to all kinds of OAuth clients, 
	including web applications.</t>
	<t>Authorization servers MUST bind authorization codes to a certain client and 
	authenticate it using an appropriate mechanism (e.g. client credentials or PKCE).</t>
	<t>Authorization servers SHOULD furthermore consider the recommendations given in 
	<xref target="RFC6819"/>, Section 4.4.1.1, on authorization code replay 
	prevention.</t>
	</section>
	<section title="Implicit Grant">
    <t>The implicit grant (response type "token") and other response types causing
    the authorization server to issue access tokens in the authorization response 
    are vulnerable to access token leakage and access token replay as described in
    <xref target="insufficient_uri_validation"/>,
    <xref target="credential_leakage_referrer"/>,
    <xref target="browser_history"/>, and <xref target="access_token_injection"/>.</t>
    <t>Moreover, no viable mechanism exists to cryptographically bind access tokens issued 
    in the authorization response to a certain client as it is recommended 
    in <xref target="token_replay_prevention"/>. This makes replay detection 
    for such access tokens at resource servers impossible.</t>
    <t>In order to avoid these issues, Clients SHOULD NOT use the implicit grant or 
    any other response type causing the authorization server to issue an access token in 
    the authorization response.</t>
    <t>Clients SHOULD instead use the response type "code" (aka authorization code
    grant type) as specified in <xref target="ac"/> or any other response type that
    causes the authorization server to issue access tokens in the token response.
    This allows the authorization server to detect replay attempts and 
    generally reduces the attack surface since access tokens are not exposed in URLs. It  
    also allows the authorization server to sender-constrain the issued tokens.</t>
	</section>
    </section>
    
    <section anchor="token_replay_prevention" title="Token Replay Prevention">
    <t>Authorization servers SHOULD use TLS-based methods for sender-constrained access 
    tokens as described in  <xref target="pop_tokens"/>, such as token 
    binding <xref target="I-D.ietf-oauth-token-binding"></xref> or Mutual TLS for 
    OAuth 2.0 <xref target="I-D.ietf-oauth-mtls"></xref> in order to prevent token replay. 
    It is also recommended to use end-to-end TLS whenever possible.</t>

    <t>If access tokens are sender-constrained to a web browser, the resource server MUST ensure that the
    access token can only be used by the origin to which the access token was issued (origin binding).
    One solution for the resource server to accomplish this is to only accept the access token in an
    <spanx style="verb">Authorization</spanx> header (as described in <xref target="RFC6750">RFC
    6750</xref>) and to ensure that the active CORS policy prevents third parties from sending <spanx
    style="verb">Authorization</spanx> headers. See <xref target="pop_tokens"/> for details.</t>
    </section>
    
    <section title="Access Token Privilege Restriction">
    <t>The privileges associated with an access token SHOULD be restricted to the
    minimum required for the particular application or use case. This prevents
    clients from exceeding the privileges authorized by the resource owner. It also
    prevents users from exceeding their privileges authorized by the respective
    security policy. Privilege restrictions also limit the impact of token leakage
    although more effective counter-measures are described in 
    <xref target="token_replay_prevention"></xref>.</t>
    <t>In particular, access tokens SHOULD be restricted to certain resource servers, 
    preferably to a single resource server. To put this into effect, the authorization server
    associates the access token with certain resource servers and every resource server 
    is obliged to verify for every request, whether the access token sent with that request 
    was meant to be used for that particular resource server.  If not, the resource server 
    MUST refuse to serve the respective request. Clients and authorization servers MAY 
    utilize the parameters 
    <spanx style="verb">scope</spanx> or <spanx style="verb">resource</spanx> as 
    specified in <xref target="RFC6749"/> and 
    <xref target="I-D.ietf-oauth-resource-indicators"/>, respectively, to determine
    the resource server they want to access.</t>
    <t>Additionally, access tokens SHOULD be restricted to certain resources and actions
    on resource servers or resources. To put this into effect, the authorization server 
    associates the access token with the respective resource and actions and every resource 
    server is obliged to verify for every request, whether the access token sent with that 
    request was meant to be used for that particular action on the particular resource.  
    If not, the resource server must refuse to serve the respective request.  
    Clients and authorization servers MAY utilize the 
    parameter <spanx style="verb">scope</spanx> as specified in <xref target="RFC6749"/> 
    to determine those resources and/or actions.</t>
    </section>
    
   </section>
   
   <section title="Attacks and Mitigations">
     <t>
       This section gives a detailed description of attacks on OAuth implementations,
       along with potential countermeasures. This section complements and enhances the 
       description given in <xref target="RFC6819"/>.
     </t>
	  <section anchor="insufficient_uri_validation" title="Insufficient Redirect URI Validation">
	  <t>Some authorization servers allow clients to register redirect URI 
	  patterns instead of 
	  complete redirect URIs. In those cases, the authorization server, 
	  at runtime, matches the actual redirect URI parameter value at the 
	  authorization endpoint against this pattern. This approach 
	  allows clients to encode transaction state into additional 
	  redirect URI parameters or to register just a single pattern for 
	  multiple redirect URIs. As a downside, it turned out to be more 
	  complex to implement and error prone to manage than exact 
	  redirect URI matching. Several successful attacks have been 
	  observed in the wild, which utilized flaws in the pattern 
	  matching implementation or concrete configurations. Such a flaw 
	  effectively breaks client identification or authentication 
	  (depending on grant and client type) and allows the attacker to 
	  obtain an authorization code or access token, either:
	  <list style="symbols">
	  <t>by directly sending the user agent to a URI under the attackers 
	  control or</t>
	  <t>by exposing the OAuth credentials to an attacker by utilizing an 
	  open redirector at the client in conjunction with the way user agents
	  handle URL fragments.</t>
	  </list>
	  </t>
	  <section title="Attacks on Authorization Code Grant" anchor="insufficient_uri_validation_acg">
	  <t>For a public client using the grant type code, an attack 
	  would look as follows: </t>
	  <t>Let's assume the redirect URL pattern "https://*.somesite.example/*" had been registered 
	  for the client "s6BhdRkqt3". This pattern allows redirect URIs pointing to any 
	  host residing  in the domain somesite.example. So if an attacker manages to 
	  establish a host or subdomain in somesite.example he can impersonate the 
	  legitimate client. Assume the attacker sets up the host 
	  "evil.somesite.example".</t>
	  <t>
	   <list style="format (%d)" counter="my_count">
	    <t>The attacker needs to trick the user into opening a tampered URL 
	  in his browser, which launches a page under the attacker's control, 
	  say "https://www.evil.example".</t>
	    <t>This URL initiates an authorization request with the client id 
	  of a legitimate client to the authorization endpoint. This is the 
	  example authorization request (line breaks are for display purposes only):
	  </t>
	   </list>	   
	  </t>
	  <t>
	  	<figure>
          <artwork><![CDATA[GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz
  &redirect_uri=https%3A%2F%2Fevil.somesite.example%2Fcb HTTP/1.1
Host: server.somesite.example]]></artwork>
        </figure>	
	  </t>
	  <t>
	  <list style="format (%d)" counter="my_count">
	  <t>The authorization server validates the redirect URI in order to identify the 
	  client. Since the pattern allows arbitrary domains host names in 
	  "somesite.example", the authorization request is processed under the legitimate 
	  client's identity. This includes the way the request for user consent is 
	  presented to the user. If auto-approval is allowed (which is not 
	  recommended for public clients according to <xref target="RFC6749"/>), the attack can be 
	  performed even easier.</t>
	  <t>If the user does not recognize the attack, the code is issued and directly 
	  sent to the attacker's client.</t>
	  <t>Since the attacker impersonated a public client, it can directly exchange 
	  the code for tokens at the respective token endpoint.</t>
	  </list>
	  </t>
	  <t>Note: This attack will not directly work for confidential clients, since the 
	  code exchange requires authentication with the legitimate client's 
	  secret. The attacker will need to impersonate or utilize the legitimate client to 
	  redeem the code (e.g., by performing a code injection attack). This kind 
	  of injections is covered in 
	  Section <xref format="title" target="code_injection"/>.</t>
	   </section>
	   <section title="Attacks on Implicit Grant">
	   <t>The attack described above works for the implicit grant as well. If the attacker 
	   is able to send the 
	   authorization response to a URI under his control, he will directly get 
	   access to the fragment carrying the access token.</t>
	   <t>Additionally, implicit clients can be subject to a further kind of attacks. 
	   It utilizes the fact that user agents re-attach fragments to the destination URL 
	   of a redirect if the location header does not contain a 
	   fragment (see <xref target="RFC7231"/>, Section 9.5). The attack described here 
	   combines this behavior with the client as an open redirector 
	   in order to get access to access tokens. This allows circumvention even of 
	   strict redirect URI patterns (but not strict URL matching!).</t>
	   <t>Assume the pattern for client "s6BhdRkqt3" is
	   "https://client.somesite.example/cb?*", i.e., any parameter is allowed for 
	   redirects to "https://client.somesite.example/cb". Unfortunately, the client 
	   exposes an open redirector. This endpoint supports a parameter 
	   "redirect_to" which takes a target URL and will send the browser to 
	   this URL using an HTTP Location header redirect 303.</t>
	  <t>
	   <list style="format (%d)" counter="my_count1">
	    <t>Same as above, the attacker needs to trick the user into opening a 
		tampered URL in his browser, which launches a page under the attacker's control, 
		say "https://www.evil.example".</t>
	    <t>The URL initiates an authorization request, which is very 
		similar to the attack on the code flow. As differences, it utilizes the 
		open redirector by encoding "redirect_to=https://client.evil.example" into 
		the redirect URI and it uses the response type "token" (line breaks 
		are for display purposes only):</t>
	   </list>	   
	  </t>
	  <t>
	  	<figure>
          <artwork><![CDATA[GET /authorize?response_type=token&client_id=s6BhdRkqt3&state=xyz
  &redirect_uri=https%3A%2F%2Fclient.somesite.example%2Fcb%26redirect_to
  %253Dhttps%253A%252F%252Fclient.evil.example%252Fcb HTTP/1.1
Host: server.somesite.example]]></artwork>
        </figure>	
	  </t>
	  <t>
	   <list style="format (%d)" counter="my_count1">
	    <t>Since the redirect URI matches the registered pattern, the authorization server 
		allows the request and sends the resulting access token with a 303 redirect (some 
		response parameters are omitted for better readability)</t>
	   </list>	   
	  </t>
	  <t>
	  	<figure>
          <artwork><![CDATA[HTTP/1.1 303 See Other
  Location: https://client.somesite.example/cb?
  redirect_to%3Dhttps%3A%2F%2Fclient.evil.example%2Fcb
  #access_token=2YotnFZFEjr1zCsicMWpAA&...]]></artwork>
        </figure>	
	  </t>	
      <t>   	  
	   <list style="format (%d)" counter="my_count1">
	    <t>At example.com, the request arrives at the open redirector. It will read the 
		redirect parameter and will issue an HTTP 303 Location header redirect to the URL "https://client.evil.example/cb".</t>
	   </list>	   
	  </t>
	  <t>
	  	<figure>
          <artwork><![CDATA[HTTP/1.1 303 See Other
     Location: https://client.evil.example/cb]]></artwork>
        </figure>	
      </t>
	  <t>
	   <list style="format (%d)" counter="my_count1">
	    <t>Since the redirector at client.somesite.example does not include a fragment in the Location header, 
		the user agent will re-attach the original fragment <vspace/>"#access_token=2YotnFZFEjr1zCsicMWpAA&amp;..." 
		to the URL and will navigate to the following URL:</t>
	   </list>	  
	  </t>
	  <t>
  	  	<figure>
          <artwork><![CDATA[https://client.evil.example/cb#access_token=2YotnFZFEjr1zCsicMWpAA&...]]></artwork>
        </figure>
	  </t>
	  <t>
	   <list style="format (%d)" counter="my_count1">	  
      <t>The attacker's page at client.evil.example can access the fragment and obtain the access token.</t>
	   </list>	  
	  </t>	  
	   </section>
	   <section title="Proposed Countermeasures">
	   <t>The complexity of implementing and managing pattern matching correctly 
		obviously causes security issues. This document therefore proposes to 
	   simplify the required logic and configuration by using exact redirect URI matching only.
       This means the authorization server must compare the two 
	   URIs using simple string comparison as defined in <xref target="RFC3986"/>, Section 6.2.1..</t>
	   <t>Additional recommendations:
	   <list style="symbols">
	   <t>Servers on which callbacks are hosted must not expose open redirectors (see <xref target="Open.Redirection"/>).</t>
	   <t>Clients MAY drop fragments via intermediary URLs with "fix fragments"
	   (see <xref target="fb_fragments"/>) to prevent the user agent from appending any unintended fragments.</t>
       <t>Clients SHOULD use the authorization code response type instead of response types causing access token issuance at the
           authorization endpoint. This offers countermeasures against reuse of leaked credentials through
       the exchange process with the authorization server and token replay through certificate binding
       of the access tokens.</t>
	   </list>
	   </t>
	   <t>As an alternative to exact redirect URI matching, the AS could also authenticate clients, e.g., using 
	   <xref target="I-D.ietf-oauth-jwsreq"/>.</t> 
	   </section>
	  </section> 
	   <section anchor="credential_leakage_referrer" title="Credential Leakage via Referrer Headers">
	     <t>Authorization codes or values of <spanx style="verb">state</spanx> can
             unintentionally be disclosed to attackers through the referrer header, by leaking either
             from a client's web site or from an AS's web site. Note: even if specified otherwise in
             <xref target="RFC2616"/>, section 14.36, the same may happen to access tokens conveyed in
             URI fragments due to browser implementation issues as illustrated by
             <xref target="bug.chromium">Chromium Issue 168213</xref>.
         </t>
         <section title="Leakage from the OAuth client">
         <t>
           This requires that the client, as a result of a successful
           authorization request, renders a page that
             </t>
             <t>
             <list style="symbols">
               <t>contains links to other pages under the attacker's control (ads, faq, ...) and a
               user clicks on such a link, or</t>
               <t>includes third-party content (iframes, images, etc.) for example if 
               the page contains user-generated content (blog).</t>
             </list>
             </t>
             <t>
             As soon as the browser navigates to the attacker's page or loads the 
             third-party content, the attacker receives the authorization response URL 
             and can extract <spanx style="verb">code</spanx>, <spanx style="verb">access token</spanx>,
             or <spanx style="verb">state</spanx>.
             </t>
        </section>
        <section title="Leakage from the Authorization Server">
            <t>In a similar way, an attacker can learn <spanx
             style="verb">state</spanx> if the authorization endpoint at the authorization server
             contains links or third-party content as above.</t>
        </section>
        <section title="Consequences">
             <t>An attacker that learns a valid code or access token through a
                 referrer header can perform the attacks as described in <xref
                 target="insufficient_uri_validation_acg"/>, <xref
                 target="code_injection"/>, and <xref
                 target="access_token_injection"/>. If the attacker learns <spanx
             style="verb">state</spanx>, the CSRF protection achieved by using <spanx
             style="verb">state</spanx> is lost, resulting in CSRF attacks as described in <xref
             target="RFC6819"/>, Section 4.4.1.8..
             </t>
       </section>
             
	   <section title="Proposed Countermeasures">
	     <t>The page rendered as a result of the OAuth authorization response and the 
	     authorization endpoint SHOULD not include third-party resources or 
	     links to external sites.</t>
         <t>The following measures further reduce the chances of a successful attack:</t>
	     <t>
	       <list style="symbols">
	       	         <t>Bind authorization code to a confidential client or PKCE challenge.
	         In this case, the attacker lacks the secret to request the code exchange.</t>
             <t>Authorization codes SHOULD be invalidated by the AS after their first use at the
             token endpoint. For example, if an AS invalidated the code after the legitimate client
             redeemed it, the attacker would fail exchanging this code later. (This does not
             mitigate the attack if the attacker manages to exchange the code for a token before the
             legitimate client does so.)</t>
             <t>The <spanx style="verb">state</spanx> value SHOULD be invalidated by the client
             after its first use at the redirection endpoint. If this is implemented, and an
             attacker receives a token through the referrer header from the client's web site, the
             <spanx style="verb">state</spanx> was already used, invalidated by the client and
             cannot be used again by the attacker. (This does not help if the <spanx
             style="verb">state</spanx> leaks from the AS's web site, since then the <spanx
             style="verb">state</spanx> has not been used at the redirection endpoint at the client
             yet.)</t>
                 <t>Suppress the referrer header by adding the attribute 
                 <spanx style="verb">rel="noreferrer"</spanx> to HTML links or by 
                 applying an appropriate Referrer Policy <xref target="webappsec-referrer-policy"/> 
                 to the document (either as part of the "referrer" meta attribute or by 
                 setting a Referrer-Policy header).</t>
             <t>Use authorization code instead of response types causing access token issuance
                 from the authorization endpoint. This provides countermeasures against
                 leakage on the OAuth protocol level through the code exchange process with
                 the authorization server.</t>
	         <t>Additionally, one might use the form post response mode instead of redirect
                 for authorization response (see <xref target="oauth-v2-form-post-response-mode"/>).</t>
               </list>
	     </t>
	   </section>
           
	  </section>
       <section anchor="browser_history" title="Attacks through the Browser History">
            <t>
              Authorization codes and access tokens can end up in the browser's history of visited URLs, enabling the attacks described in the following.
            </t>
	  <section title="Code in Browser History">
	  <t>When a browser navigates to "client.example/redirection_endpoint?code=abcd" as a result 
	  of a redirect from a provider's authorization endpoint, the URL including the 
	  authorization code may end up in the browser's history. An attacker
	  with access to the device could obtain the code and try to replay it.</t>
	  <t>Proposed countermeasures:
	  	<list style="symbols">
	  		<t>Authorization code replay prevention as described in 
	  		<xref target="RFC6819"/>, Section 4.4.1.1, and <xref target="code_injection"/></t>
			<t>Use form post response mode instead of redirect for authorization 
	  			response (see <xref target="oauth-v2-form-post-response-mode"/>)</t>
	  	</list>
	  </t>
	  </section>
	  <section title="Access Token in Browser History">
	  <t>An access token may end up in the browser history if a a client or just a web 
	  site, which already has a token, deliberately navigates to a page like 
	  "provider.com/get_user_profile?access_token=abcdef.". 
	  Actually <xref target="RFC6750"/> discourages this practice and asks to transfer 
	  tokens via a header, but in practice web sites often just pass access token in 
	  query parameters.</t>
	  <t>In case of implicit grant, a URL like 
	  "client.example/redirection_endpoint#access_token=abcdef" may also end up in the browser 
	  history as a result of a redirect from a provider's authorization endpoint.</t>
	  <t>Proposed countermeasures:
	  	<list style="symbols">
	  		<t>Replace implicit flow with postmessage communication or 
	  		the authorization code grant</t>
	  		<t>Never pass access tokens in URL query parameters</t>
	  	</list>
	  </t>
	  </section>
	  </section>
	  
	  <section title="Mix-Up">
	  <t>Mix-up is an attack on scenarios where an OAuth client interacts with multiple
	  authorization servers, as is usually the case when dynamic registration is used. The goal
	  of the attack is to obtain an authorization code or an access token by tricking the client
	  into sending those credentials to the attacker instead of using them at the respective
	  endpoint at the authorization/resource server.</t>
      <section title="Attack Description">
        <t>For a detailed attack description, refer to <xref target="arXiv.1601.01229"/> and <xref
        target="I-D.ietf-oauth-mix-up-mitigation"/>. The description here closely follows <xref
        target="arXiv.1601.01229"/>, with variants of the attack outlined below.</t>
        <t>Preconditions: For the attack to work, we assume that
        <list style="format (%d)">
          <t>the implicit or authorization code grant are used with
          multiple AS of which one is considered "honest" (H-AS) and
          one is operated by the attacker (A-AS),</t>
          <t>the client stores the AS chosen by the user in a session
          bound to the user's browser and uses the same redirection
          endpoint URI for each AS, and</t>
          <t>the attacker can manipulate the first request/response
          pair from a user's browser to the client (in which the user
          selects a certain AS and is then redirected by the client to
          that AS).</t>
        </list>
        Some of the attack variants described below require different preconditions.
        </t>
        <t>In the following, we assume that the client is registered
        with H-AS (URI: "https://honest.as.example", client id:
        7ZGZldHQ) and with A-AS (URI: "https://attacker.example",
        client id: 666RVZJTA).</t>
        <t>Attack on the authorization code grant:
        <list style="format (%d)" counter="counter_mixup_acg">
          <t>The user selects to start the grant using H-AS (e.g., by clicking on a button at the
          client's website).</t>
          <t>The attacker intercepts this request and changes the user's selection to "A-AS".</t>
          <t>The client stores in the user's session that the user
          selected "A-AS" and redirects the user to A-AS's
          authorization endpoint by sending the following response:
          </t>
        </list>
        </t>
        <t>
        <figure>
          <artwork><![CDATA[HTTP/1.1 303 See Other
  Location: https://attacker.example/authorize?response_type=code&client_id=666RVZJTA]]></artwork>
        </figure>
        </t>
        <t>
        <list style="format (%d)" counter="counter_mixup_acg">
          <t>Now the attacker intercepts this response and changes the
          redirection such that the user is being redirected to H-AS.
          The attacker also replaces the client id of the client at
          A-AS with the client's id at H-AS, resulting in the following response being sent to the browser:
          </t>
        </list>
        </t>
        <t>
          <figure>
            <artwork><![CDATA[HTTP/1.1 303 See Other
  Location: https://honest.as.example/authorize?response_type=code&client_id=7ZGZldHQ]]></artwork>
          </figure>
          </t>
        <t>
        <list style="format (%d)" counter="counter_mixup_acg">
          <t anchor="list_mixup_acg_after_authep">Now, the user authorizes the client to access her
          resources at H-AS. H-AS issues a code and sends it (via the browser) back to the
          client.</t>
          <t>Since the client still assumes that the code was issued by A-AS, it will try to redeem
          the code at A-AS's token endpoint.</t>
          <t>The attacker therefore obtains code and can either exchange the code for an access
          token (for public clients) or perform a code injection attack as described in
          <xref target="code_injection"/>.</t>
        </list>
        </t>
        <t>Variants:
        <list hangIndent="8" style="hanging">
          <t hangText="Implicit Grant">
            In the implicit grant, the attacker receives an access token instead of the code; the
            rest of the attack works as above.
          </t>
          <t hangText="Mix-Up Without Interception">
            A variant of the above attack works even if the first request/response pair cannot be
            intercepted (for example, because TLS is used to protect these messages): Here, we
            assume that the user wants to start the grant using A-AS (and not H-AS). After the
            client redirected the user to the authorization endpoint at A-AS, the attacker
            immediately redirects the user to H-AS (changing the client id "7ZGZldHQ"). (A vigilant
            user might at this point detect that she intended to use A-AS instead of H-AS.) The
            attack now proceeds exactly as in step <xref format="counter"
            target="list_mixup_acg_after_authep"/> of the attack description above.  <!-- I think this counter is not working properly! -->
          </t>
          <t hangText="Per-AS Redirect URIs">
            If clients use different redirect URIs for different ASs, do not store the selected AS
            in the user's session, and ASs do not check the redirect URIs properly, attackers can
            mount an attack called "Cross-Social Network Request Forgery". We refer to <xref
            target="oauth_security_jcs_14"/> for details.
          </t>
          <t hangText="OpenID Connect">
            There are several variants that can be used to attack OpenID Connect. They are described
            in detail in <xref target="arXiv.1704.08539" />, Appendix A, and <xref
            target="arXiv.1508.04324v2" />, Section 6 ("Malicious Endpoints Attacks").
          </t>
        </list>
        </t>
      </section>
      <section title="Countermeasures">
        <t>In scenarios where an OAuth client interacts with multiple authorization servers, clients
        MUST prevent mix-up attacks.</t>
        <t>Potential countermeasures:
	<list style="symbols">
	  <t>Configure authorization servers to return an AS identitifier (<spanx
	  style="verb">iss</spanx>) and the <spanx style="verb">client_id</spanx> for which a code
	  or token was issued in the authorization response. This enables clients to compare this
	  data to their own client id and the <spanx style="verb">iss</spanx> identifier of the AS
	  it believed it sent the user agent to. This mitigation is discussed in detail in <xref
	  target="I-D.ietf-oauth-mix-up-mitigation"/>. In OpenID Connect, if an ID token is
	  returned in the authorization response, it carries client id and issuer. It can be used
	  for this mitigation.</t>
	  <t>As it can be seen in the preconditions of the attacks above, clients can prevent mix-up
	  attack by (1) using AS-specific redirect URIs with exact redirect URI matching, (2)
	  storing, for each authorization request, the intended AS, and (3) comparing the intended
	  AS with the actual redirect URI where the authorization response was received.</t>
	</list>
	</t>
      </section>
	  </section>
	  
	  <section anchor="code_injection" title="Authorization Code Injection">
	  <t>In such an attack, the adversary attempts to inject a stolen authorization 
	  code into a legitimate client on a device under his control. In the simplest 
	  case, the attacker would want to use the code in his own client. But there
	  are situations where this might not be possible or intended. Examples are:
	  <list style="symbols">
	   <t>The attacker wants to access certain functions in this particular client. 
	   As an example, 
	   the attacker wants to impersonate his victim in a certain app or on a certain 
	   web site.</t>
	   <t>The code is bound to a particular confidential client and the attacker is 
	   unable to obtain the required client credentials to redeem the code himself.</t>
	   <t>The authorization or resource servers are limited to certain networks, the 
	   attackers is unable to access directly.</t>
	   </list>
	   </t>
	   <t>How does an attack look like?</t>
	   <t>
	   <list style="format (%d)">
	    <t>The attacker obtains an authorization code by performing any of the attacks 
	    described above.</t>
		<t>It performs a regular OAuth authorization process with the legitimate client on 
		his device.</t>
		<t>The attacker injects the stolen authorization code in the response of the 
		authorization server to the legitimate client.</t>
		<t>The client sends the code to the authorization server's token endpoint, 
		along with client id, client secret and actual <spanx style="verb">redirect_uri</spanx>.</t>
		<t>The authorization server checks the client secret, whether the code was issued 
		to the particular client and whether the actual redirect URI matches the 
		<spanx style="verb">redirect_uri</spanx> parameter (see <xref target="RFC6749"/>).</t>
		<t>If all checks succeed, the authorization server issues access 
		and other tokens to the client, so now the attacker is able to impersonate 
		the legitimate user.</t>
	   </list>
	   </t>
	   <t>Obviously, the check in step (5) will fail, if the code was issued to 
	   another client id, e.g., a client set up by the attacker. The check will also fail 
	   if the authorization code was already redeemed by the legitimate user and was
	   one-time use only.</t>
	   <t>An attempt to inject a code obtained via a malware pretending to be the 
	   legitimate client should also be detected, if the authorization server stored the 
	   complete redirect URI used in the authorization request and compares it with 
	   the redirect_uri parameter.</t>
	   <t><xref target="RFC6749"/>, Section 4.1.3, requires the AS to 
	   "... ensure that the "redirect_uri" 
	   parameter is present if the "redirect_uri" parameter was included in the initial 
	   authorization request as described in Section 4.1.1, and if included ensure that 
	   their values are identical.". In the attack scenario described above, the legitimate 
	   client would use the correct redirect URI it always uses for authorization requests. 
	   But this URI would not match the tampered redirect URI used by the attacker (otherwise, 
	   the redirect would not land at the attackers page). So the authorization server would 
	   detect the attack and refuse to exchange the code.</t>
	   <t>Note: this check could also detect attempt to inject a code, which had been obtained 
	   from another instance of the same client on another device, if certain conditions are fulfilled:
	   <list style="symbols">
	   <t>the redirect URI itself needs to contain a nonce or another kind of one-time use, 
	   secret data and</t>
	   <t>the client has bound this data to this particular instance.</t>
	   </list>
	   </t>
	   <t>But this approach conflicts with the idea to enforce exact redirect URI matching 
	   at the authorization endpoint. Moreover, it has been observed that providers very often ignore the 
	   redirect_uri check requirement at this stage, maybe because it doesn't seem to be security-critical 
	   from reading the spec.</t>
	   <t>Other providers just pattern match the redirect_uri parameter against the registered 
	   redirect URI pattern. This saves the authorization server from storing the link between the 
	   actual redirect URI and the respective authorization code for every transaction. But this kind of 
	   check obviously does not fulfill the intent of the spec, since the tampered redirect URI is not 
	   considered. So any attempt to inject a code obtained using the <spanx style="verb">client_id</spanx> of a legitimate client 
	   or by utilizing the legitimate client on another device won't be detected in the respective deployments.</t>
       <t>It is also assumed that the requirements defined in <xref target="RFC6749"/>, Section 4.1.3, 
	   increase client implementation 
	   complexity as clients need to memorize or re-construct the correct redirect URI for the call 
	   to the tokens endpoint.</t>
	   <t>This document therefore recommends to instead bind every authorization code to a certain 
	   client instance on a certain device (or in a certain user agent) in the context of a 
	   certain transaction.</t>
	   <section title="Proposed Countermeasures">
	   <t>There are multiple technical solutions to achieve this goal:</t>
	    <t>
		<list hangIndent="8" style="hanging">
		 <t hangText="Nonce">OpenID Connect's existing <spanx style="verb">nonce</spanx> 
		 parameter could be used for this purpose. 
		 The nonce value is one-time use and created by the client. The client is supposed to bind 
		 it to the user agent session and sends it with the initial request to the OpenId Provider 
		 (OP). The OP associates the nonce to the authorization code and attests this binding in the
		 ID token, which is issued as part of the code exchange at the token endpoint. If an attacker 
		 injected an authorization code in the authorization response, the nonce value in the client 
		 session and the nonce value in the ID token will not match and the attack is detected.
		 The assumption is that an attacker cannot get hold of the user agent state on the victims device, where he 
		 has stolen the respective authorization code. The main advantage of this option is that Nonce
		 is an existing feature used in the wild. On the other hand, leveraging Nonce by
		 the broader OAuth community would require AS and client to adopt ID Tokens.</t>
		 <t hangText="Code-bound State">The <spanx style="verb">state</spanx> parameter 
		 as specified in <xref target="RFC6749"/> could be used similarly to
		  what is described above. This would require to add a further parameter 
		  <spanx style="verb">state</spanx> to the code exchange token endpoint request. 
		 The authorization server would then compare the <spanx style="verb">state</spanx> value it associated with 
		 the code and the <spanx style="verb">state</spanx> value in the parameter. If those values do not match, 
		 it is considered an attack and the request fails. The advantage of this approach 
		 would be to utilize an existing OAuth parameter. But it would also mean to 
		 re-interpret the purpose of <spanx style="verb">state</spanx> and to extend the token endpoint request.</t>
		 <t hangText="PKCE">The PKCE parameter <spanx style="verb">challenge</spanx> along  
		 with the corresponding <spanx style="verb">verifier</spanx> as specified 
		 in <xref target="RFC7636"/> could be used in the same way 
		 as <spanx style="verb">nonce</spanx> or 
		 <spanx style="verb">state</spanx>. In contrast to its original intention, the verifier 
		 check would fail although the client uses its correct verifier but the code is 
		 associated with a challenge, which does not match. PKCE is a deployed OAuth feature,
		 even though it is used today to secure native apps, only.</t>
		 <t hangText="Token Binding">Token binding 
		 <xref target="I-D.ietf-oauth-token-binding"/> could also be used. In this case, the 
		 code would need to be bound to two legs, between user agent and AS and the user 
		 agent and the client. This requires further data (extension to response) to 
		 manifest binding id for particular code. Token binding is promising as a 
		 secure and convenient mechanism (due to its browser integration). As a challenge, 
		 it requires broad browser support and use with native apps is still under 
		 discussion.</t>
		 <t hangText="per instance client id/secret">One could use per instance <spanx style="verb">client_id</spanx> 
		 and secrets and bind the code to the respective <spanx style="verb">client_id</spanx>. Unfortunately, 
		 this does not fit into the web application programming model (would need to use 
		 per user client ids).</t>		 
		</list>
		</t>
		<t>PKCE seems to be the most obvious solution for OAuth clients as it available and 
		effectively used today for similar purposes for OAuth native apps whereas 
		<spanx style="verb">nonce</spanx> is appropriate for OpenId Connect clients.</t>
		<t>Note on pre-warmed secrets: An attacker can circumvent the countermeasures 
		described above if he is able to create or capture the respective secret or 
		code_challenge on a device under his control, which is then used in the victim's 
		authorization request. 
		<vspace/>Exact redirect URI matching of authorization requests can prevent the 
		attacker from using the pre-warmed secret in the faked authorization transaction 
		on the victim's device. 
		<vspace/>Unfortunately, it does not work for all kinds of OAuth clients. It is 
		effective for web and JS apps and for native apps with claimed URLs. Attacks on
		native apps using custom schemes or redirect URIs on localhost cannot be prevented
		this way, except if the AS enforces one-time use for PKCE verifier or <spanx style="verb">nonce</spanx> 
		values.</t>
	   </section>
	   	  </section>
      
       <section anchor="access_token_injection" title="Access Token Injection">
           <t>In such an attack, the adversary attempts to inject a stolen access token
               into a legitimate client on a device under his control. This will typically
               happen if the attacker wants to utilize a leaked access token to impersonate
           a user in a certain client.</t>
           <t>To conduct the attack, the adversary starts an OAuth flow with the client
               and modifies the authorization response by replacing the access token
               issued by the authorization server or directly makes up an authorization
               server response including the leaked access token. Since the response includes
               the state value generated by the client for this particular transaction,
               the client does not treat the response as a CSRF and will use the
               access token injected by the attacker.</t>
           <section title="Proposed Countermeasures">
               <t>There is no way to detect such an injection
                   attack on the OAuth protocol level, since the token is issued without
                   any binding to the transaction
                   or the particular user agent.</t>
               <t>The recommendation is therefore to use the authorization code
                   grant type instead of relying on response types issuing acess tokens
               at the authorization endpoint. Code injection can be detected using one of
               the countermeasures discussed in <xref target="code_injection"/>.</t>
           </section>
       </section>
       
	   <section title="Cross Site Request Forgery">
	   <t>An attacker might attempt to inject a request to the redirect URI of the 
	   legitimate client on the victim's device, e.g., to cause the client to access 
	   resources under the attacker's control.</t>
	   <section title="Proposed Countermeasures" anchor="csrf_countermeasures">
             <t>Standard CSRF defenses should be used to protect the redirection endpoint, for example:</t>
             <t>
             <list hangIndent="15" style="hanging">
               <t hangText="CSRF Tokens">Use of CSRF tokens which are
               bound to the user agent and passed in the <spanx style="verb">state</spanx>
               parameter to the authorization server.</t>
               <t hangText="Origin Header">The Origin header can be
               used to detect and prevent CSRF attacks. Since this
               feature, at the time of writing, is not consistently
               supported by all browsers, CSRF tokens should be used
               in addition to Origin header checking.</t>
             </list>
             </t>
             <t>For more details see <xref target="owasp_csrf"/>.</t>
           </section>
	   </section>

	   <section title="Access Token Leakage at the Resource Server">
             <t>Access tokens can leak from a resource server under certain circumstances.</t>
	  
	  <section title="Access Token Phishing by Counterfeit Resource Server">
	  <t>An attacker may setup his own resource server and trick 
	  a client into sending access tokens to it, which are valid for
	  other resource servers. If the client sends a valid access token to 
	  this counterfeit resource server, the attacker in turn may use that 
	  token to access other services on behalf of the resource owner.</t>
	<t>This attack assumes the client is not bound to a certain
	resource server (and the respective URL) at development time, but 
	client instances are configured with an resource server's URL at runtime. 
	This kind of late binding is typical in situations where the client
	uses a standard API, e.g., for e-Mail, calendar, health, or banking
	and is configured by an user or administrator for the standard-based 
	service, this particular user or company uses.</t>
	
   	  <t>There are several potential mitigation strategies, which will be discussed 
   	  in the following sections.</t>
   	  
      <section title="Metadata">
      <t>An authorization server could provide the client with additional
      information about the location where it is safe to use its access tokens. </t>
      <t>In the simplest 
      form, this would require the AS to publish a list of its known resource 
      servers, illustrated in the following example using a metadata parameter 
      <spanx style="verb">resource_servers</spanx>:</t>
      
      	  <t>
  	  	<figure>
          <artwork><![CDATA[HTTP/1.1 200 OK
Content-Type: application/json

{
  "issuer":"https://server.somesite.example",
  "authorization_endpoint":
    "https://server.somesite.example/authorize",
  “resource_servers”:[
    “email.somesite.example”,
    ”storage.somesite.example”,
    ”video.somesite.example”]
  ...
}]]></artwork>
        </figure>
	  </t>
      
      <t>
      The AS could also return the URL(s) an access token is good
      for in the token response, illustrated by the example return parameter 
      <spanx style="verb">access_token_resource_server</spanx>:</t>
      
      	  <t>
  	  	<figure>
          <artwork><![CDATA[HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
  "access_token":"2YotnFZFEjr1zCsicMWpAA",
  “access_token_resource_server”:
    "https://hostedresource.somesite.example/path1",            
...
}]]></artwork>
        </figure>
	  </t>      
      <t>This mitigation strategy would rely on the client to enforce the security
      policy and to only send access tokens to legitimate destinations. Results
      of OAuth related security research (see for example 
      <xref target="oauth_security_ubc"/> and <xref target="oauth_security_cmu"/>) 
      indicate a large portion 
      of client implementations do not or fail to properly implement security controls,
      like <spanx style="verb">state</spanx> checks. So relying on clients to prevent access token
      phishing is likely to fail as well. Moreover given the ratio of clients to authorization
      and resource servers, it is considered the more viable approach to move as much as 
      possible security-related logic to those entities. Clearly, the client has to
      contribute to the overall security. But there are alternative countermeasures, as
      described in the next sections, which provide a better balance between the involved
      parties.</t>    
	  </section>
	  
	 <section anchor="pop_tokens" title="Sender-Constrained Access Tokens"> 

		 <t>As the name suggests, sender-constrained access token scope the applicability 
		 of an access token to a certain sender. This sender is obliged to demonstrate 
		 knowledge of a certain secret as prerequisite for the acceptance of that token 
		 at a resource server.</t>
		 
		 <t>A typical flow looks like this:
		 <list style="numbers">
		 <t>The authorization server associates data with the access token which binds 
		 this particular token to a certain client. The binding can utilize the client 
		 identity, but in most cases the AS utilizes key material (or data derived from 
		 the key material) known to the client.</t>
		 <t>This key material must be distributed somehow. Either the key material 
		 already exists before the AS creates the binding or the AS creates ephemeral 
		 keys. The way pre-existing key material is distributed varies among the 
		 different approaches. For example, X.509 Certificates can be used in which 
		 case the distribution happens explicitly during the enrollment process. Or the 
		 key material is created and distributed at the TLS layer, in which case it might 
		 automatically happens during the setup of a TLS connection.</t>
		 <t>The RS must implement the actual proof of possession check. This is typically 
		 done on the application level, it may utilize capabilities of the transport 
		 layer (e.g., TLS). Note: replay prevention is required as well!</t>
		 </list>
		 </t>
		 	 
		 <t>There exists several proposals to demonstrate the proof of possession in 
		 the scope of the OAuth working group:
		 <list style="symbols">
		 <t><xref target="I-D.ietf-oauth-token-binding"></xref>: In this approach,
		 an access tokens is, via the so-called token binding id, bound to key material 
		 representing a long term association between a client and a certain TLS host.
		 Negotiation of the key material and proof of possession in the context of 
		 a TLS handshake is taken care of by the TLS stack. The client needs to determine 
		 the token binding id of the target resource server and pass this data to the 
		 access token request. The authorization server than associates the access 
		 token with this id. The resource server checks on every invocation that the 
		 token binding id of the active TLS connection and the token binding id of 
		 associated with the access token match. Since all crypto-related functions
		 are covered by the TLS stack, this approach is very client developer friendly. 
		 As a prerequisite, token binding as described in 
		 <xref target="I-D.ietf-tokbind-https"></xref> (including federated token bindings) 
		 must be supported on all ends (client, authorization server, resource server).</t>
		 <t><xref target="I-D.ietf-oauth-mtls"></xref>: The approach as specified in this
		 document allow use of mutual TLS for both client authentication and sender 
		 constraint access tokens. For the purpose of sender constraint access tokens, 
		 the client is identified towards the resource server by the fingerprint of its 
		 public key. During processing of an access token request, the 
		 authorization server obtains the client's public key from the TLS stack and 
		 associates its fingerprint with the respective access tokens. The resource server
		 in the same way obtains the public key from the TLS stack and compares 
		 its fingerprint with the fingerprint associated with the access token.</t>
		 <t><xref target="I-D.ietf-oauth-signed-http-request"></xref> specifies an approach 
		 to sign HTTP requests. It utilizes 
		 <xref target="I-D.ietf-oauth-pop-key-distribution"></xref> and represents 
		 the elements of the signature in a JSON object. The signature is built using JWS. 
		 The mechanism has built-in support for signing of HTTP method, query parameters 
		 and headers. It also incorporates a timestamp as basis for replay prevention.</t>
		 <t><xref target="I-D.sakimura-oauth-jpop"></xref>: this draft describes different 
		 ways to constrain access token usage, namely TLS or request signing. Note: Since 
		 the authors of this draft contributed the TLS-related proposal to 
		 <xref target="I-D.ietf-oauth-mtls"></xref>, this document only considers the
		 request signing part. For request signing, 
		 the draft utilizes <xref target="I-D.ietf-oauth-pop-key-distribution"></xref> and 
		 <xref target="RFC7800">RFC 7800</xref>. The signature data is 
		 represented in a JWT and JWS is used for signing. Replay prevention is provided 
		 by building the signature over a server-provided nonce, client-provided nonce 
		 and a nonce counter.</t>
		 </list>
		 </t>
		  
		 <t><xref target="I-D.ietf-oauth-mtls"></xref> and   
		 <xref target="I-D.ietf-oauth-token-binding"></xref> are built on top of TLS and 
		 this way continue the successful OAuth 2.0 philosophy to leverage TLS to secure
		 OAuth wherever possible. Both mechanisms allow prevention of access token leakage 
		 in a fairly client developer friendly way.</t>
		 <t>There are some differences between both approaches: To 
		 start with, in <xref target="I-D.ietf-oauth-token-binding"></xref> all key material 
		 is automatically managed by the TLS stack whereas 
		 <xref target="I-D.ietf-oauth-mtls"></xref> requires the developer to create and 
		 maintain the key pairs and respective certificates. Use of self-signed 
		 certificates, which is supported by the draft, significantly reduce the 
		 complexity of this task. Furthermore, 
		 <xref target="I-D.ietf-oauth-token-binding"></xref> 
		 allows to use different key pairs for different resource servers, which is 
		 a privacy benefit. 
		 On the other hand, <xref target="I-D.ietf-oauth-mtls"></xref> only 
		 requires widely deployed TLS features, which means it might be easier to adopt
		 in the short term.</t>
		 
		 <t>Application level signing approaches, like 
		 <xref target="I-D.ietf-oauth-signed-http-request"></xref> and
		 <xref target="I-D.sakimura-oauth-jpop"></xref> have been debated for a long time
		 in the OAuth working group without a clear outcome.</t>
		 
		 <t>As one advantage, application-level signing allows for end-to-end protection 
		 including non-repudiation even if the TLS connection is terminated between client 
		 and resource server. But deployment experiences have revealed challenges 
		 regarding robustness (e.g., reproduction of the signature base
		 string including correct URL) as well as state management (e.g., replay prevention).</t>
		 
		 <t>This document therefore recommends implementors to consider one of 
		 TLS-based approaches wherever possible.</t>

                 
                 <t>It is important to note that constraining the sender of a token to a web browser
                 (using a TLS-based method) does not constrain the origin of the script that uses the
                 token (lack of origin binding). In other words, if access tokens are used in a browser
                 (as in a single-page application, SPA) and the access tokens are sender-constrained
                 using a TLS-based method, it must be ensured that origins other than the origin of the
                 SPA cannot misuse the TLS-based sender authentication.</t>
                 <t>The problem can be illustrated using an SPA on origin A that uses an access token AT
                 that is bound to the TLS connection between the browser and the resource server R. If AT
                 leaks to an attacker E, and there is, for example, an iframe from E's origin loaded in
                 the web browser, that iframe can send a request to origin R using the access token AT.
                 This request will contain the proof-of-posession of the (mTLS or token binding) key. The
                 resource server R therefore cannot distinguish if a request containing a valid access
                 token originates from origin A or origin E.</t>
                 <t>If the resource server only accepts the access token in an <spanx
                 style="verb">Authorization</spanx> header, then Cross-Origin Resource Sharing (CORS)
                 <xref target="cors"></xref> will protect against this attack by default.</t>
                 <t>If the resource server accepts the access tokens in other ways (e.g., as a URL
                 parameter), or if the CORS policy of the resource server permits requests by origin E,
                 then the TLS-based token binding only provides protection if the browser is offline.</t>

	</section>
	<section anchor="aud_restriction" title="Audience Restricted Access Tokens"> 
		<t>An audience restriction essentially restricts the resource server a 
		particular access token can be used at. The authorization server associates
		the access token with a certain resource server and every resource server
		is obliged to verify for every request, whether the access token sent with
		that request was meant to be used at the particular resource server. If
		not, the resource server must refuse to serve the respective request. In
		the general case, audience restrictions limit the impact of a token 
		leakage. In the case of a counterfeit resource server, it may (as described 
		see below) also prevent abuse of the phished access token at the legitimate 
		resource server.</t>
		<t>The audience can basically be expressed using logical names or physical 
		addresses (like URLs). In order to prevent phishing, it is necessary to use 
		the actual URL the client will send requests to. 
		In the phishing case, this URL will point to the 
		counterfeit resource server. If the attacker tries to use the access token 
		at the legitimate resource server (which has a different URL), the resource 
		server will detect the mismatch (wrong audience) and refuse to serve the 
		request.</t>
		<t>In deployments where the authorization server knows the URLs of all resource
		servers, the authorization server may just refuse to issue access tokens for
		unknown resource server URLs.</t>
		<t>The client needs to tell the authorization server, at which URL it will
		use the access token it is requesting. It could use the mechanism proposed
		<xref target="I-D.ietf-oauth-resource-indicators"></xref> or
		encode the information in the scope value.</t>
		<t>Instead of the URL, it is also possible to utilize the fingerprint of
		the resource server's X.509 certificate as audience value. This variant would
		also allow to detect an attempt to spoof the legit resource server's URL by using 
		a valid TLS certificate obtained from a different CA. It might also be considered
		a privacy benefit to hide the resource server URL from the authorization 
		server.</t>
	     <t>Audience restriction seems easy to use since it does not require any 
	     crypto on the client side. But since every access token is bound to a certain
	     resource server, the client also needs to obtain different RS-specific
	     access tokens, if it wants to access several resource services. 
	     <xref target="I-D.ietf-oauth-token-binding"></xref> has the same property, since
	     different token binding ids must be associated with the access token. 
	     <xref target="I-D.ietf-oauth-mtls"></xref> on the other hand allows a 
	     client to use the access token at multiple resource servers.</t>
	     <t>It shall be noted that audience restrictions, or generally speaking an 
	     indication by the client to the authorization server where it wants to use 
	     the access token, has additional benefits beyond the scope of token leakage 
	     prevention. It allows the authorization server to create different access 
	     token whose format and content is specifically minted for the respective server. 
	     This has huge functional and privacy advantages in deployments using
	     structured access tokens.</t>
	  </section>
	  </section>
	   <section title="Compromised Resource Server">
	   <t>An attacker may compromise a resource server in order to get access
	   to its resources and other resources of the respective deployment. 
	   Such a compromise may range from partial access to the system, e.g., its logfiles, 
	   to full control of the respective server.</t> 
	   <t>If the attacker was able to take over full control including shell access
	   it will be able to circumvent all controls in place and 
	   access resources without access control. It will also get access
	   to access tokens, which are sent to the compromised system and which potentially 
	   are valid for access to other resource servers as well. Even if the attacker "only"
	   is able to access logfiles or databases of the server system, it may get access to 
	   valid access tokens.</t>   
	   <t>Preventing server breaches by way of hardening and monitoring 
	   server systems is considered a standard operational procedure and therefore out
	   of scope of this document. This section will focus on the impact of
	   such breaches on OAuth-related parts of the ecosystem, which is the replay of 
	   captured access tokens on the compromised resource server and other resource 
	   servers of the respective deployment.</t>
	   <t>The following measures should be taken into account by implementors in order 
	   to cope with access token replay:</t>
	   <t>
	   <list style="symbols">
	     <t>The resource server must treat access tokens like any other credentials. It
	     is considered good practice to not log them and not to store them in plain text.</t> 
	     <t>Sender constraint access tokens as described in 
	     <xref target="pop_tokens"/> will prevent the attacker from replaying the access
	     tokens on other resource servers. Depending on the severity of the penetration, 
	     it will also prevent replay on the compromised system.</t> 
	     <t>Audience restriction as described in <xref target="aud_restriction"/>
	     may be used to prevent replay of captured access tokens on other resource
	     servers.</t>
	   </list>
       </t>
	   </section>
	   
	  </section>

          <section anchor="Open.Redirection" title="Open Redirection">
            <t>The following attacks can occur when an AS or client
            has an open redirector, i.e., a URL which causes an HTTP
            redirect to an attacker-controlled web site.</t>
            
            <section title="Authorization Server as Open Redirector">
	      <t>Attackers could try to utilize a user's trust in the authorization 
	      server (and its URL in particular) for performing phishing attacks.</t>
	      <t><xref target="RFC6749"/>, Section 4.1.2.1, already prevents open redirects 
	      by stating the AS MUST NOT automatically redirect the user agent in case of 
	      an invalid combination of client_id and redirect_uri.</t>
	      <t>However, as described in <xref target="I-D.ietf-oauth-closing-redirectors"/>, an
	      attacker could also utilize a correctly registered redirect URI to 
	      perform phishing attacks. It could for example register a client
	      via dynamic client <xref target="RFC7591"/> 
	      registration and intentionally send an 
	      erroneous authorization request, e.g., by using an invalid 
	      scope value, to cause the AS to automatically redirect the user
	      agent to its phishing site.</t>
	      <t>The AS MUST take precautions to prevent this threat. 
	      Based on its risk assessment the AS needs to decide whether 
	      it can trust the redirect URI or not and SHOULD only automatically 
	      redirect the user agent, if it trusts the redirect URI. If not, it MAY
	      inform the user that it is about to redirect her to the another site 
	      and rely on the user to decide or MAY just inform the user about the 
	      error.</t>
            </section>
            <section title="Clients as Open Redirector">
	      <t>Client MUST NOT expose URLs which could be utilized as open redirector.
	      Attackers may use an open redirector to produce URLs which appear to 
	      point to the client, which might trick users to trust the URL and follow
	      it in her browser. Another abuse case is to produce URLs pointing to the 
	      client and utilize them to impersonate a client with an authorization server.</t>
	      <t>In order to prevent open redirection, clients should only expose such a 
	      function, if the target URLs are whitelisted or if the origin of a request 
	      can be authenticated.</t>
            </section>
          </section>

          <section title="307 Redirect">
            <t>At the authorization endpoint, a typical protocol flow is that the AS prompts the
            user to enter her credentials in a form that is then submitted (using the HTTP POST
            method) back to the authorization server. The AS checks the credentials and, if
            successful, redirects the user agent to the client's redirection endpoint.</t>
            <t>In <xref target="RFC6749"/>, the HTTP status code 302 is used for this purpose, but
            "any other method available via the user-agent to accomplish this redirection is
            allowed". However, when the status code 307 is used for redirection, the user agent will
            send the form data (user credentials) via HTTP POST to the client since this status code
            does not require the user agent to rewrite the POST request to a GET request (and
            thereby dropping the form data in the POST request body). If the relying party is
            malicious, it can use the credentials to impersonate the user at the AS.</t>
            <t>In the HTTP standard <xref target="RFC6749"/>, only the status code 303 unambigiously
            enforces rewriting the HTTP POST request to an HTTP GET request. For all other status
            codes, including the popular 302, user agents can opt not to rewrite POST to GET
            requests and therefore to reveal the user credentials to the client. (In practice,
            however, most user agents will only show this behaviour for 307 redirects.)</t>
            <t>AS which redirect a request that potentially contains user credentials therefore MUST
            not use the HTTP 307 status code for redirection. If an HTTP redirection (and not, for
            example, JavaScript) is used for such a request, AS SHOULD use HTTP status code 303 "See
            Other".</t>
          </section>
	
          <section title="TLS Terminating Reverse Proxies">
	   <t>A common deployment architecture for HTTP applications is to 
	   have the application server sitting behind a reverse proxy, which terminates
	   the TLS connection and dispatches the incoming requests to the respective 
	   application server nodes.</t>
	   <t>This section highlights some attack angles of this deployment architecture,
	   which are relevant to OAuth, and give recommendations for security controls.</t>
	   <t>In some situations, the reverse proxy needs to pass security-related data
	   to the upstream application servers for further processing. Examples include the IP 
	   address of the request originator, token binding ids and authenticated TLS 
	   client certificates.</t>
	   <t>If the reverse proxy would pass through any header sent from the outside,
	   an attacker could try to directly send the faked header values through the proxy
	   to the application server in order to circumvent security controls that way.
	   For example, it is standard practice of reverse proxies to accept 
	   <spanx style="verb">forwarded_for</spanx>
	   headers and just add the origin of the inbound request (making it a list). 
	   Depending on the logic performed in the application server, the attacker could
	   simply add a whitelisted IP address to the header and render a IP whitelist 
	   useless. A reverse proxy must therefore sanitize any inbound requests to ensure
	   the authenticity and integrity of all header values relevant for the security of the 
	   application servers.</t>
	   <t>If an attacker would be able to get access to the internal network between 
	   proxy and application server, it could also try to circumvent security 
	   controls in place. It is therefore important to ensure the authenticity of 
	   the communicating entities. Furthermore, the communication link between reverse 
	   proxy and application server must therefore be protected against tapping and 
	   injection (including replay prevention).</t>
	  </section>
	  
	  <section title="Refresh Token Protection">
	
		<t>Refresh tokens are a convenient and UX-friendly way to obtain new access
		tokens after the expiration of older access tokens. Refresh tokens also add
		to the security of OAuth since they allow the authorization server to issue
		access tokens with a short lifetime and reduced scope thus reducing the 
		potential impact of access token leakage.</t>
		<t>Refresh tokens themself are an attractive target for attackers since 
		they represent the overall grant a resource owner delegated to a certain client.
		If an attacker is able to exfiltrate and successfully replay a refresh token, it 
		will be able to mint access tokens and use them to access resource servers
		on behalf of the resource server.</t>
		
		<t><xref target="RFC6749"/> already provides robust base protection by 
		requiring
		<list style="symbols">
		 <t>confidentiality of the refresh tokens in transit and storage,</t>
		 <t>the transmission of refresh tokens over TLS-protected connections between 
		 authorization server and client,</t>
		 <t>the authorization server to maintain and check the binding of a refresh token 
		 to a certain client_id,</t>
		 <t>authentication of this client_id during token refresh, if possible, and</t>
		 <t>that refresh tokens cannot be generated, modified, or guessed.</t>
	    </list>
	    </t>
	    <t>
	    <xref target="RFC6749"/> also lays the foundation for further (implementation
	    specific) security measures, such as refresh token expiration and revocation 
	    as well as refresh token rotation by defining respective error codes and 
	    response behavior.</t> 
	    
	    <t>This draft gives recommendations beyond the scope of <xref target="RFC6749"/>
	    and clarifications.</t>
    	<t>Authorization servers MUST determine based on their risk assessment whether 
    	to issue refresh tokens to a certain client. If the authorization server decides
    	not to issue refresh tokens, the client may refresh access tokens by utilizing 
    	other grant types, such as the authorization code grant type. In such a case,
    	the authorization server may utilize cookies and persistents grants to optimize
    	the user experience.</t>
    	<t>If refresh tokens are issued, those refresh tokens MUST be bound to the scope 
    	and resource servers as consented by the resource owner. This is to prevent
    	privilege escalation by the legit client and reduce the impact of refresh tokens
    	leakage.</t>
    	
    	<t>Authorization server MUST utilize one of the methods listed below to detect 
    	refresh token replay for public clients:
    	<list style="symbols">
    	<t>Refresh token rotation: the authorization issues a new refresh token 
    	with every access token refresh response.  The previous refresh token is 
    	invalidated but information about the relationship is retained by the 
    	authorization server.  If a refresh token is 
    	compromised and subsequently used by both the attacker and the legitimate client, 
    	one of them will present an invalidated refresh token, which will inform the 
    	authorization server of the breach. The authorization server cannot determine 
    	which party submitted the invalid refresh token, but it can revoke the active 
    	refresh token. This stops the attack at the cost of forcing the legit client to 
    	obtain a fresh authorization grant.</t>
    	<t>Sender constrained refresh tokens: the authorization server cryptographically 
    	binds the refresh token to a certain client instance by utilizing 
    	<xref target="I-D.ietf-oauth-token-binding"/> or 
    	<xref target="I-D.ietf-oauth-mtls"/>.</t>
    	</list>
    	</t>
    	
    	<t>Authorization servers may revoke refresh tokens automatically in case of 
    	a security event, such as: 
    	<list style="symbols">
    	<t>password change</t>
    	<t>logout at the authorization server</t>
    	</list>
    	</t>
    	
    	<t>Refresh tokens SHOULD expire if the client has been inactive for some time, 
    	i.e. the refresh token has not been used to obtain fresh access tokens for 
    	some time. The expiration time is at the discretion of the authorization server. 
    	It might be a global value or determined based on the client policy or
    	the grant associated with the refresh token (and its sensitivity).</t>
    	
    </section>
	
	</section>
	
    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>We would like to thank Jim Manico, Phil Hunt, Nat Sakimura, Christian Mainka, 
      Doug McDorman, Johan Peeters, Joseph Heenan, Brock Allen, Aaron Parecki, and 
      Brian Campbell for their valuable feedback.</t>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This draft includes no request to IANA.</t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>All relevant security considerations have been given in the
      functional specification.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
    
    <?rfc include="reference.RFC.2119"?>
      <?rfc include="reference.RFC.3986"?>
      <?rfc include="reference.RFC.6749"?>
      <?rfc include="reference.RFC.6750"?>
      <?rfc include="reference.RFC.6819"?>
	  <?rfc include="reference.RFC.7231"?>
	  <?rfc include="reference.RFC.7591"?>
    </references>
    
    <references title="Informative References">
         <?rfc include="reference.RFC.2616"?>
    <?rfc include="reference.RFC.7636"?>       
    <?rfc include="reference.RFC.8414"?>    
    <?rfc include='http://xml.resource.org/public/rfc/bibxml3/reference.I-D.bradley-oauth-jwt-encoded-state.xml'?>       
    <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-token-binding.xml'?>
    <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-mtls.xml'?>
    <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-signed-http-request.xml'?>
    <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.sakimura-oauth-jpop.xml'?>
    <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-tokbind-https.xml'?>
    <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-pop-key-distribution'?>
    <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-resource-indicators'?>
    <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-jwsreq'?> 
    <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-mix-up-mitigation'?> 
    <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-oauth-closing-redirectors'?>   
     
    <?rfc include="reference.RFC.7800"?>
    
       <reference anchor="OpenID" target="http://openid.net/specs/openid-connect-core-1_0.html">
        <front>
          <title>OpenID Connect Core 1.0 incorporating errata set 1</title>

		  <author fullname="Nat Sakimura">
            <organization>NRI</organization>
          </author>
          <author fullname="John Bradley">
            <organization>Ping Identity</organization>
          </author>
          <author fullname="Mike Jones">
            <organization>Microsoft</organization>
          </author>
          <author fullname="Breno de Medeiros">
            <organization>Google</organization>
          </author>
          <author fullname="Chuck Mortimore">
            <organization>Salesforce</organization>
          </author>
         <date day="8" month="Nov" year="2014"/>
        </front>
      </reference>
    
    <reference anchor="owasp" target="https://www.owasp.org/">
        <front>
          <title>Open Web Application Security Project Home Page</title>

          <author></author>

          <date />
        </front>
      </reference>
      
    <reference anchor="fb_fragments" target="https://developers.facebook.com/blog/post/552/">
        <front>
          <title>Facebook Developer Blog</title>
          <author></author>
          <date />
        </front>
      </reference>

      
      
      
        <reference anchor="owasp_csrf" target="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet">
        <front>
          <title>Cross-Site Request Forgery (CSRF) Prevention Cheat Sheet</title>

          <author></author>

          <date />
        </front>
      </reference>
      
      
       <reference anchor="webappsec-referrer-policy" target="https://w3c.github.io/webappsec-referrer-policy">
        <front>
          <title>Referrer Policy</title>

		  <author fullname="Jochen Eisinger">
            <organization>Google Inc.</organization>
          </author>
          <author fullname="Emily Stark">
            <organization>Google Inc.</organization>
          </author>
          <date day="20" month="April" year="2017"/>
        </front>
      </reference>

       <reference anchor="cors" target="https://www.w3.org/TR/cors/">
        <front>
          <title>Cross-Origin Resource Sharing</title>

		  <author fullname="Anne van Kesteren">
          </author>
          <date day="16" month="January" year="2014"/>
        </front>
      </reference>

      
       <reference anchor="oauth-v2-form-post-response-mode" target="http://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html">
        <front>
          <title>OAuth 2.0 Form Post Response Mode</title>

		  <author fullname="Mike Jones">
            <organization>Microsoft</organization>
          </author>
          <author fullname="Brian Campbell">
            <organization>Ping Identity</organization>
          </author>
          <date day="27" month="April" year="2015"/>
        </front>
      </reference>       
      
      
      <reference anchor="oauth_security_ubc" target="http://passwordresearch.com/papers/paper267.html">
        <front>
          <title>The Devil is in the (Implementation) Details: An Empirical Analysis of OAuth SSO Systems</title>
          <author fullname="San-Tsai Sun">
            <organization abbrev="UBC">University of British Columbia</organization>
          </author>
          <author fullname="Konstantin Beznosov">
            <organization abbrev="UBC">University of British Columbia</organization>
          </author>
          <date month="October" year="2012"/>
        </front>
        <format target="http://passwordresearch.com/papers/paper267.html" type="HTML" />
      </reference> 
    
      <reference anchor="oauth_security_cmu">
        <front>
          <title>OAuth Demystified for Mobile Application Developers</title>
          <author fullname="Eric Chen">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>
          <author fullname="Yutong Pei">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>
           <author fullname="Shuo Chen">
            <organization abbrev="MR">Microsoft Research</organization>
          </author>
          <author fullname="Yuan Tian">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>          
          <author fullname="Robert Kotcher">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>
          <author fullname="Patrick Tague">
            <organization abbrev="CMU">Carnegie Mellon University</organization>
          </author>        
          <date month="November" year="2014"/>
        </front>
        <format target="http://css.csail.mit.edu/6.858/2012/readings/oauth-sso.pdf" type="pdf" />
      </reference>

      <reference anchor="arXiv.1601.01229"
		 target="http://arxiv.org/abs/1601.01229/">
	<front>
	  <title>A Comprehensive Formal Security Analysis of OAuth 2.0</title>
	  <author fullname="Daniel Fett" surname="Fett" initials="D."><organization/></author>
	  <author fullname="Ralf Küsters" surname="Küsters" initials="R."><organization/></author>
	  <author fullname="Guido Schmitz" surname="Schmitz" initials="G."><organization/></author>

	  <date day="6" month="January" year="2016"/>
	</front>
	<seriesInfo name="arXiv" value="1601.01229"/>
      </reference>

      <reference anchor="arXiv.1704.08539"
		 target="http://arxiv.org/abs/1704.08539/">
	<front>
	  <title>The Web SSO Standard OpenID Connect: In-Depth Formal Security Analysis and Security Guidelines</title>
	  <author fullname="Daniel Fett" surname="Fett" initials="D."><organization/></author>
	  <author fullname="Ralf Küsters" surname="Küsters" initials="R."><organization/></author>
	  <author fullname="Guido Schmitz" surname="Schmitz" initials="G."><organization/></author>

	  <date day="27" month="April" year="2017"/>
	</front>
	<seriesInfo name="arXiv" value="1704.08539"/>
      </reference>

      <reference anchor="arXiv.1508.04324v2"
		 target="http://arxiv.org/abs/1508.04324v2/">
	<front>
	  <title>On the security of modern Single Sign-On Protocols: Second-Order Vulnerabilities in OpenID Connect</title>
	  <author fullname="Vladislav Mladenov" surname="Mladenov" initials="V."><organization/></author>
	  <author fullname="Christian Mainka" surname="Mainka" initials="C."><organization/></author>
	  <author fullname="Jörg Schwenk" surname="Schwenk" initials="J."><organization/></author>

	  <date day="7" month="January" year="2016"/>
	</front>
	<seriesInfo name="arXiv" value="1508.04324v2"/>
      </reference>

      <reference anchor="oauth_security_jcs_14">
        <front>
          <title>Discovering concrete attacks on website authorization by formal analysis</title>
	      <author fullname="Chetan Bansal" surname="Bansal" initials="C."><organization/></author>
          <author fullname="Karthikeyan Bhargavan" surname="Bhargavan" initials="K."><organization/></author>
          <author fullname="Antoine Delignat-Lavaud" surname="Delignat-Lavaud" initials="A."><organization/></author>
          <author fullname="Sergio Maffeis" surname="Maffeis" initials="S."><organization/></author>
          
	      <date day="23" month="April" year="2014"/>
        </front>
        <format target="https://www.doc.ic.ac.uk/~maffeis/papers/jcs14.pdf" type="pdf" />
      </reference>

      <reference anchor="bug.chromium" target="https://bugs.chromium.org/p/chromium/issues/detail?id=168213/">
      <front>
      <title>Referer header includes URL fragment when opening link using New Tab</title>
      
      <author></author>
      
      <date />
      </front>
      </reference>
      
    </references>
    
    <section anchor="History" title="Document History">
      <t>[[ To be removed from the final specification ]]</t>
      <t>-11 <list style="symbols">
        <t>more text on refresh token inactivity</t>
      </list>
      </t>
      <t>-10 <list style="symbols">
        <t>incorporated feedback by Joseph Heenan</t>
        <t>changed occurrences of SHALL to MUST</t>
        <t>added text on lack of token/cert binding support
        tokens issued in the authorization response as
        justification to not recommend issuing tokens there at all</t>
        <t>added requirement to authenticate clients during 
        code exchange (PKCE or client credential) to 2.1.1.</t>
        <t>added section on refresh tokens</t>
        <t>editorial enhancements to 2.1.2 based on feedback</t>
      </list>
      </t>      
      <t>-09 <list style="symbols">
        <t>changed text to recommend not to use implicit but code</t>
        <t>added section on access token injection</t>
        <t>reworked sections 3.1 through 3.3 to be more specific on
        implicit grant issues</t>
      </list>
      </t>
      <t>-08 <list style="symbols">
      	  <t>added recommendations re implicit and token injection</t>
      	  <t>uppercased key words in Section 2 according to RFC 2119</t>
        </list> 
      </t>
      <t>-07 <list style="symbols">
      	  <t>incorporated findings of Doug McDorman</t>
      	  <t>added section on HTTP status codes for redirects</t>
      	  <t>added new section on access token privilege restriction
      	  based on comments from Johan Peeters</t>
        </list> 
      </t>
      <t>-06 <list style="symbols">
      	  <t>reworked section 3.8.1</t>
      	  <t>incorporated Phil Hunt's feedback</t>
      	  <t>reworked section on mix-up</t>
      	  <t>extended section on code leakage via referrer header to also 
      	  cover state leakage</t>
      	  <t>added Daniel Fett as author</t>
      	  <t>replaced text intended to inform WG discussion by recommendations to implementors</t>
      	  <t>modified example URLs to conform to RFC 2606</t>
        </list></t> 
      <t>-05 <list style="symbols">
      	  <t>Completed sections on code leakage via referrer header, attacks in 
      	  browser, mix-up, and CSRF</t>
          <t>Reworked Code Injection Section</t>
          <t>Added reference to OpenID Connect spec</t>
          <t>removed refresh token leakage as respective considerations 
          have been given in section 10.4 of RFC 6749</t>
          <t>first version on open redirection</t>
          <t>incorporated Christian Mainka's review feedback</t>
        </list></t>       
      <t>-04 <list style="symbols">
      	  <t>Restructured document for better readability</t>
          <t>Added best practices on Token Leakage prevention</t>
        </list></t>      
      <t>-03 <list style="symbols">
      	  <t>Added section on Access Token Leakage at Resource Server</t>
          <t>incorporated Brian Campbell's findings</t>
        </list></t>      
      <t>-02 <list style="symbols">
          <t>Folded Mix up and Access Token leakage through a bad AS 
          into new section for dynamic OAuth threats</t>
          <t>reworked dynamic OAuth section</t>
        </list></t>
      <t>-01 <list style="symbols">
          <t>Added references to mitigation methods for token leakage</t>
          <t>Added reference to Token Binding for Authorization Code</t>
          <t>incorporated feedback of Phil Hunt</t>
          <t>fixed numbering issue in attack descriptions in section 2</t>
        </list></t>
      <t>-00 (WG document)<list style="symbols">
          <t>turned the ID into a WG document and a BCP</t>
          <t>Added federated app login as topic in Other Topics</t>
        </list></t>  
        
    </section>		
  </back>
</rfc>
